---
title: "GDOC Recidivism Analysis"
---




## Introduction

Our DOC captures 10 Evidence Based Recidivism Reduction (EBRR) programs in 2017 listed by the Federal Bureau of Prisons and the individuals involved:

* Anger Management
* The Bureau Rehabilitation and Values Enhancement Program
* Basic Cognitive Skills
* The Resolve Program
* Residential Drug Abuse Program
* Dialectical Behavior Therapy
* Sex Offender Treatment Program
* Challenge Program
* Mental Health Step Down Program
* Steps Toward Awareness, Growth, and Emotional Strength Program

Your DOC Research Department tracks clients served and staff involved in running and supporting these programs.




```{r setup, echo=FALSE, warning=FALSE, message=FALSE}
#libraries
#packages
#install.packages("charlatan")
#install.packages("tidyverse")
#install.packages("knitr")
#install.packages("ggrepel)
#install.packages("summarytools")
#install.packages("DT")
#install.packages("devtools")
#devtools::install_github("kent37/summarywidget")
#devtools::install_github("rstudio/crosstalk")
#install.packages("downloadthis")
#install.packages("quarto")
#install.packages("rmarkdown")
#install.packages("officer")

#activate!!
library(charlatan)
library(lubridate)
library(tidyverse)
library(knitr)
library(ggrepel)
library(summarytools)
library(DT)
library(devtools)
library(summarywidget)
library(crosstalk)
library(downloadthis)
library(quarto)
library(rmarkdown)
library(officer)


#data setup
#programs
#https://www.bop.gov/inmates/fsa/docs/fsa_program_guide_2107.pdf
#https://www.bop.gov/inmates/fsa/docs/evidence_based_recidivism_reduction_programs.pdf

#for participants
prgnm = c("am,0",        "am,0",        "am,0",        "am,0",        "am,0",                      "am,1",        "am,1",        "am,1",        #CWC
          
          "brave,0",     "brave,0",     "brave,0",     "brave,0",     "brave,0",                   "brave,1",                                        #spelling error below
          
          "bcs,0",       "bcs,0",                                                                  "bcs,1",       "bcs,1",                           #spelling error below
          
          "resolve,0",   "resolve,0",                                                              "resolve,1",   "resolve,1",
          
          "rdap,1",      "rdap,1",      "rdap,1",      #CWC #spelling error below 
          
          "dbt,1",       "dbt,1",                      #CWC #spelling error below
          
          "sotrt,0",                                                                               "sotrt,1",     "sotrt,1",
          
          "challenge,0", "challenge,0", "challenge,0", "challenge,0", "challenge,0", "challenge,0","challenge,1", "challenge,1",                #CWC
          
          "mhsd,0",      "mhsd,0",                                                                 "mhsd,1",
          
          "stages,0",    "stages,0",    "stages,0",    "stages,0",    "stages,0",    "stages,0",   "stages,1",    "stages,1",    "stages,1",    #CWC
          
          #spelling errors
          "bgs,0", "bgs,0",
          "fbt,0", "fbt,0",
          "brv,0", "brv,0",
          "rdp,0", "rdp,0")

#for staff
prgnm2 = c("am",
           "brave",
           "bcs",
           "resolve",
           "rdap",
           "dbt",
           "sotrt",
           "challenge",
           "mhsd",
           "stages",
           #spelling errors
           "brv",
           "stg",
           "resol")

#dataframe sizes: sizen - roster, sizen2 - program staff, sizen3 - 2nd roster
sizen  = 50 #DO NOT CHANGE - THIS IS SIZE OF DATA BEING SAMPLED ABOVE
date1  = 2017
date2  = 2018

##staff
sizen2 = 80 #2017-2018 staff
sizen4 = 84 #2021-2022 staff

############################################
#####set up roster/recidivism dataframe#####
############################################
#create person-level dataframe
set.seed(80)
roster.prep <- data.frame(
  #create names
  client_names  = ch_name(sizen),
  #create age
  age           = round(rnorm(sizen,29,5)),
  #create programs/returns to prison
  #data being sampled is exactly 50
  programs.temp = sample(prgnm, size=50, replace = FALSE),
  #create dates in programs
  dt            = as.Date("2018-01-01") + round(rnorm(sizen, mean = 0, sd = 120))
) |>
  #split programs/returns
  mutate(programs  = substr(programs.temp,1,nchar(programs.temp)-2),
         ret       = as.numeric(substr(programs.temp,nchar(programs.temp),nchar(programs.temp))),
         #put in a random date to throw things off
         dt        = case_when(row_number() == sizen-3  ~ as.Date(paste0('2007/06/05')), 
                               row_number() == sizen-20 ~ as.Date(paste0('1997/08/22')),
                               TRUE ~ dt),
         #put in a random return values
         ret       = case_when(row_number() == sizen-10  ~ -1, 
                               row_number() == sizen-30  ~ 11,
                               row_number() == sizen-17  ~ 2,
                               TRUE ~ ret)
  ) |>
  select(-c(programs.temp)) 

#create duplicates
roster <- roster.prep |> 
  filter(row_number() %in% c(1:5)) |> 
  bind_rows(roster.prep)

###############################################################
#####set up roster/recidivism dataframe for updated roster#####
###############################################################
#create 1000 person dataframe
sizen3 = 1000
date3  = 2021
date4  = 2022

set.seed(20012)
roster.update <- data.frame(
  client_names    = ch_name(sizen3),
  age             = round(rnorm(sizen3,29,5)),
  programs.temp   = sample(prgnm, size=sizen3, replace = TRUE),
  dt       = as.Date("2022-01-01") + round(rnorm(sizen, mean = 0, sd = 120))
) |>
  mutate(programs = substr(programs.temp,1,nchar(programs.temp)-2),
         ret  = as.numeric(substr(programs.temp,nchar(programs.temp),nchar(programs.temp)))
  ) |>
  select(-c(programs.temp))

########################################
#####set up program staff dataframe#####
########################################
#create 80 person dataframe
set.seed(160)
staff <- data.frame(
  staff = ch_name(sizen2,messy=TRUE),
  prg   = sample(prgnm2, size=sizen2, replace = TRUE)
)
set.seed(160)
staff.update <- data.frame(
  staff = ch_name(sizen4,messy=TRUE),
  prg   = sample(prgnm2, size=sizen4, replace = TRUE)
)


###################################
####write out dataframes to CSV####
###################################
write.csv(roster,"roster.csv", row.names = FALSE)
write.csv(roster.update,"rosterupdate.csv", row.names = FALSE)
write.csv(staff,"staff.csv", row.names = FALSE)
write.csv(staff.update,"staffupdate.csv", row.names = FALSE)

```

```{r toggle, echo=FALSE}
#toggle data and year format
casestudydata <- function(csdata = "roster.csv", staffdata = "staff.csv", byyear = F) {
  if (csdata == "roster.csv" & staffdata == "staff.csv") {valset <<- 0} else if (csdata == "rosterupdate.csv" & staffdata == "staffupdate.csv") {valset <<- 1}
  ALL.BY    <<- byyear
  dataname1 <<- noquote(substr(csdata,1,nchar(csdata)-4))
  dataname2 <<- noquote(substr(staffdata,1,nchar(staffdata)-4))
}

#csdata - set the roster program data to run (roster.csv or rosterupdate.csv)
#staffdata - set the staff data to run (staff.csv or staffupdate.csv)
#byyear - set to T or F (T is run analysis by year, F is run analysis overall years), default is F

casestudydata("roster.csv", "staff.csv", F)

#ANALYSIS TOGGLE
######################################
roster  <- if(valset==0) {roster} else {roster.update} #options: roster; roster.update
date1   <- if(valset==0) {date1}  else {date3}         #options: date1 (within roster); date3 (within roster.update)
date2   <- if(valset==0) {date2}  else {date4}         #options: date2 (within roster); date4 (within roster.update)
staff   <- if(valset==0) {staff}  else {staff.update}  #options: staff; staff.update
######################################


#colors
date1c  <- "deepskyblue1"
date2c  <- "darkolivegreen3"
staffc  <- "brown"
hlinew1 <- "orange"
hlinew2 <- "darkgrey"
```

```{r remove, echo=FALSE}
#programs to remove per the CWC report
rm.pgms <- c("bcs", "brave", "sotrt", "mhsd", "resolve")

```




## Data Exploration




```{r explore1, echo=FALSE, include=FALSE}
#what's in our data
print(dfSummary(roster, varnumbers = FALSE, valid.col = FALSE), 
      method = "render", footnote = NA)

#capture number of columns for printing in text
numcol <- ncol(roster)
```




Let's take a look at this EBRR program data. The name of our data is ``r dataname1``. Trying to gather anything from raw data row by row can be painful. We need to explore and synthesize what variables/columns we have, and get a quick summary of what they all look like. We know that GDOC has 10 programs. How can we find out more?

::: {.panel-tabset .nav-pills}

## Quick look




```{r look}
datatable(roster, rownames=FALSE, options=list(pageLength=5, dom='ltip'))
```




## Summary




```{r explore2}
#| ref-label: 'explore1'
```




:::

From what the summary above shows us, it appears we have `r numcol` variables in the ``r dataname1`` dataset. What further exploring, cleaning, and manipulation is required for us to successfully produce results for Director Summers?

## Data Cleaning and Manipulation

### Duplicates

What other pieces of information might be relevant to what we need to know about the data? Since it appears to be person-level data from our data exploration summary, let's check to make sure that there aren't any duplicate observations.




```{r explore4}
#are there any duplicates?
roster[duplicated(roster) | duplicated(roster, fromLast=TRUE),]

#how many duplicates?
dupct <- length(unique(
  roster[duplicated(roster) | duplicated(roster, fromLast=TRUE),]
  ))
```




<br />

It's a really good thing we checked! From the table above it appears we have `r dupct` duplicate observations/rows in our data. Let's remove them and keep exploring!




```{r nodup}
#| code-fold: show
#deduplicate across all columns
roster.nodup <- roster[!duplicated(roster), ]


#check for dups again
roster.nodup[duplicated(roster.nodup) | duplicated(roster.nodup, fromLast=TRUE),]

```




<br />

Alright! No more duplicates! What else could require cleaning that we haven't thought of?

### Recoding

We need to take a closer look at our other variables that may help us report out what the GDOC director needs. Let's start with our `programs`, `dt`, and `ret`.

::: {.panel-tabset .nav-pills}

## PROGRAMS




```{r explore5}
#count total number of programs
define_keywords(title.freq = "PROGRAMS values")
print(freq(roster.nodup$programs, report.nas = FALSE, cumul = FALSE, display.type = FALSE), 
      method = "render", footnote = NA, Variable = "")

#count number of programs
prgnum <- n_distinct(roster.nodup$programs)
```




## DT




```{r explore6}
#check out weird date values
yeardt <- as.factor(year(roster.nodup$dt))
define_keywords(title.freq = "DT values")
print(freq(yeardt, report.nas = FALSE, cumul = FALSE, display.type = FALSE), 
      method = "render", footnote = NA, Variable = "")
```




## RET




```{r explore7}
#check out weird return values
define_keywords(title.freq = "RET values")
print(freq(roster.nodup$ret, report.nas = FALSE, cumul = FALSE, display.type = FALSE), 
      method = "render", footnote = NA, Variable = "")
```




:::

Hm - it looks like there are more than 10 programs; `r prgnum` programs to be exact. That doesn't match what you know about your GDOC EBRR programs! Could there be something wrong with the data? It looks like there are also some errors in your data across `programs`, `ret`, and `dt`! 

We'll probably have to make some assumptions on our data. For example, `ret` must be our variable that indicates whether an individual enrolled in an EBRR program returned to prison within 365 days of their release. While the majority of the values are 0s and 1s, a select few are greater than 1 or less than 0. Clean them up and check your work so you can accurately report all EBRR programs and their associated recidivism rates.

::: {.panel-tabset .nav-pills}

## PROGRAMS Clean




```{r cleanroster1}
#clean program names
roster.clean <- roster.nodup |>
  #fix programs, dates, and returns
  mutate(programs_clean = case_when(programs == "bgs" ~ "bcs",
                                    programs == "fbt" ~ "dbt",
                                    programs == "brv" ~ "brave",
                                    programs == "rdp" ~ "rdap",
                                    TRUE ~ programs),
         
         #dates - assume that wrong dates occurred in 2017
         dt      = case_when(year(dt) < 2017 ~ `year<-`(dt, 2017),
                             TRUE ~ dt),
         
         #returns - assume that wrong returns should all be =1
         ret            = case_when(ret == -1 ~ 1,
                                    ret == 2  ~ 1,
                                    ret == 11 ~ 1,
                                    TRUE ~ ret)
  )


#review cleaned program names
roster.clean |>
  count(programs_clean)
```




## DT Clean




```{r cleanroster2}
#review date values
roster.clean |>
  count(year(dt))
```




## RET Clean




```{r cleanroster3}
#review out weird return values
roster.clean |>
  count(ret)

```




:::

Much better! 10 programs (`programs_clean`) as expected for our DOC, and cleaned dates (`dt`) and returns (`ret`)! 

### Calculating rates

Now that we have a clean dataset, we can finally calculate recidivism rates for all of our programs. Since we have dates spanning two years from the `dt` column, from `r min(roster.clean$dt)` to `r max(roster.clean$dt)`, perhaps we should calculate recidivism rates overall and by year.

::: {.panel-tabset .nav-pills}

## Overall




```{r explore8}
##create dataset of numerators and denominators
#recidivism rates overall
roster2.1 <- roster.clean |>
  mutate(year = factor(year(dt))) |>
  select(-c(client_names,age,programs)) |>
  group_by(programs_clean) |>
  count(ret) |>
  mutate(clients_served = sum(n),
         recid_rate_all = case_when(ret == 1 ~ round(n/clients_served,2),
                                    ret == 0 ~ 0)
  ) |>
  group_by(programs_clean) |>
  slice(n()) |>
  select(-c(ret, n)) |>
  rename(clients_served_all = clients_served)

#recidivism rates by year
roster2.2 <- roster.clean |>
  mutate(year = factor(year(dt))) |>
  select(-c(client_names,age,programs)) |>
  group_by(programs_clean,year) |>
  count(ret,year) |>
  mutate(clients_served = sum(n),
         recid_rate_year= case_when(ret == 1 ~ round(n/clients_served,2),
                                    ret == 0 ~ 0)
  ) |>
  group_by(programs_clean,year) |>
  slice(n()) |>
  select(-c(ret, n)) |>
  rename(clients_served_year = clients_served)

#combine data by programs to capture recidivism rates overall and by year
roster2 <- inner_join(roster2.1, roster2.2, by = "programs_clean")


#verify that join did not lose any observations
triplecheck <- anti_join(roster2.1, roster2.2, by = "programs_clean")


#print out overall rates
roster2.1 |>
  arrange(programs_clean) |>
  select(programs_clean,recid_rate_all) |> datatable(rownames=FALSE, colnames=c('Program', 'Overall Recidivism Rate'), 
                          options=list(pageLength=10, dom='t'))
```




## By Year




```{r explore9}
#CROSSTALK by year rates
shared_roster2 <- SharedData$new(roster2.2 |>
  arrange(year,programs_clean) |>
  select(year,programs_clean,recid_rate_year))

filter_checkbox("year", "Select Year", shared_roster2, ~year, inline=FALSE)
datatable(shared_roster2, rownames=FALSE, colnames=c('Year', 'Program', 'Recidivism Rate'), 
                          options=list(pageLength=10, dom='tip'))
```




:::

### Staff data

Great work! Now let's take a look at our program staffing! Our DOC captures 10 Evidence Based Recidivism Reduction (EBRR) programs listed by the Federal Bureau of Prisons and the individuals involved. The name of our data is ``r dataname2``.




```{r explorestaff1}
#what's in our data
print(dfSummary(staff, varnumbers = FALSE, valid.col = FALSE), 
      method = "render", footnote = NA)

#capture number of columns for printing in text
numcolst <- ncol(staff)
```




<br />

It appears we only have `r numcolst` variables in the program staffing data. Let's keep exploring! It appears to be person-level data **again**! Why don't we check for duplicates just in case.




```{r explorestaff4}
#| code-fold: show
#are there any duplicates?
staff[duplicated(staff) | duplicated(staff, fromLast=TRUE),]
```




<br />




```{r staffval, include=FALSE}
#count total number of programs
prgnum.stf <- n_distinct(staff$prg)
```




Phew! No duplicates. That was a close one. 

Looking closer at the summary, yet again we have data with more than 10 programs; `r prgnum.stf` to be exact. And there appear to be some errors in the data (again!?)! Clean them up so you can accurately report all EBRR programs and their associated program staff, and let's see how many staff we have by program! We'll be able to use this in our final report to our Director.

::: {.panel-tabset .nav-pills}

## PRG




```{r explorestaff5}
#count total number of programs
define_keywords(title.freq = "PRG values")
print(freq(staff$prg, report.nas = FALSE, cumul = FALSE, display.type = FALSE), 
      method = "render", footnote = NA, Variable = "")
```




## PRG Clean




```{r cleanstaff}
#clean program names
staff.clean <- staff |>
  mutate(programs_clean = case_when(prg == "resol" ~ "resolve",
                                    prg == "brv" ~ "brave",
                                    prg == "stg" ~ "stages",
                                    TRUE ~ prg))

#create dataset of staff counts
staff2 <- staff.clean |>
  select(-c(staff,prg)) |>
  count(programs_clean) |>
  rename(num_staff = n)


#check cleaned program names
staffcheck <- staff.clean |>
  count(programs_clean,prg)

#print staffing
staff.clean |>
  count(programs_clean)

```




:::

## Reporting Results

### Data Visualizations

We have to get out those results **now!** Let's combine the program staff and recidivism rates data so we can print out a table for our Director. Create some tables and put them into a format the Director will appreciate.

::: {.panel-tabset .nav-pills}

## Tables: Overall




```{r merge}
#create table dataset
tabout <- inner_join(roster2, staff2, by = ("programs_clean")) |>
  select(-c(clients_served_all, clients_served_year)) |>
  ungroup() |>
  #if any years are missing, fill in
  complete(year, nesting(programs_clean,num_staff),
           fill = list(recid_rate_all = NA, recid_rate_year = NA)
  ) |>
  #correct missing values for recid_rate_all since this is the overall recidivism rate across multiple years
  group_by(programs_clean) |>
  fill(recid_rate_all, .direction = "updown") |>
  ungroup() |>
  #create final program names for table
  mutate(program_official = case_when(programs_clean == "am"        ~ "Anger Management",
                                      programs_clean == "bcs"       ~ "Basic Cognitive Skills",
                                      programs_clean == "brave"     ~ "The Bureau Rehabilitation and Values Enhancement Program",
                                      programs_clean == "challenge" ~ "Challenge Program",
                                      programs_clean == "dbt"       ~ "Dialectical Behavior Therapy",
                                      programs_clean == "mhsd"      ~ "Mental Health Step Down Program",
                                      programs_clean == "rdap"      ~ "Residential Drug Abuse Program",
                                      programs_clean == "resolve"   ~ "The Resolve Program",
                                      programs_clean == "sotrt"     ~ "Sex Offender Treatment Program",
                                      programs_clean == "stages"    ~ "Steps Toward Awareness, Growth, and Emotional Strength Program",
                                      TRUE ~ programs_clean))

#for positioning in plotting
last <- tail(tabout$programs_clean,n=1)


#verify join was successful
joincheck <- anti_join(roster2, staff2, by = ("programs_clean"))

#print out overall rates and staff
reportit <- tabout |> 
  filter(year==date1) |>
  select(c(program_official, recid_rate_all, num_staff))

reportit |> 
  datatable(extensions = 'Buttons', rownames=FALSE, colnames=c('Program', 'Recidivism Rate', 'Staffing'), 
                          options=list(pageLength=10, dom='Bt',
  buttons = list(
          list(extend = "csv", text = "Download Data", filename = "data",
               exportOptions = list(
                 modifier = list(page = "all")))
)
)
)
```




## Tables: By Year




```{r merge2}
#CROSSTALK by year rates and staff
tabout2 <- SharedData$new(tabout |> 
  select(c(year, program_official, recid_rate_year, num_staff)))

filter_checkbox("year", "Select Year", tabout2, ~year, inline=FALSE)
datatable(tabout2, extensions = 'Buttons', rownames=FALSE, colnames=c('Year', 'Program', 'Recidivism Rate', 'Staffing'), 
                          options=list(pageLength=10, dom='Btip',
 buttons = list(
          list(extend = "csv", text = "Download Table View", filename = "view_year",
               exportOptions = list(
                 modifier = list(page = "current")
               )
          ),
          list(extend = "csv", text = "Download Data", filename = "data",
               exportOptions = list(
                 modifier = list(page = "all")))
)
)
)
```




:::

::: {.callout-important}
## Important

Save this for the final report!
:::

These tables are fantastic! But I recall that our Director is a bit of a "visual" person. Can we turn these into some pretty charts?

::: {.panel-tabset .nav-pills}

## Plots: Overall




```{r basicviz1, warning=FALSE}
#basic bar chart of overall recidivism rate by program
ggplot(tabout |>
         filter(year == date1)
       ,aes(x=programs_clean, y=recid_rate_all)) +
  geom_bar(stat="identity")
```




## Plots: By Year




```{r basicviz2, warning=FALSE}
#basic bar chart of recidivism rate by year by program
ggplot(tabout,aes(x=programs_clean, y=recid_rate_year,fill=year)) +
         geom_bar(position="dodge", stat="identity")

```




:::

Oh I think we could do better than that!




```{r dataviz1, warning=FALSE}
#build bar chart of recidivism rates across programs
#information to plot, pick dates
dates <- as.numeric(c(date1,date2)) #what years of data do you want to plot?

#custom title header of plot
titledates <- ifelse(length(dates)>=2 & date1 != date2, paste0(date1," - ",date2),
                     ifelse((dates==date1 | dates==date2) & ALL.BY, as.character(dates),
                            ifelse(!ALL.BY, date1, "")))

#which years/programs are missing data?
prg.NA <- tabout |> 
  filter(is.na(recid_rate_year)) |>
  pull(programs_clean)

#plot it! this will plot recidivism rates with overlaid staffing text
rr <- ggplot(tabout |> 
               filter(if(ALL.BY) year %in% dates else year == date2) |>
               mutate(recid_rate = case_when(ALL.BY  ~ recid_rate_year,
                                             !ALL.BY ~ recid_rate_all))
             ,aes(x=programs_clean, y=recid_rate, fill=year)) +
  geom_bar(position = "dodge",stat = "identity", na.rm=TRUE) +
  geom_text(aes(label=ifelse(year==dates[2],paste(num_staff,"staff"),"")), vjust=-0.3, color = staffc, na.rm=TRUE) +
  scale_fill_manual(values=c(date1c,date2c)) +
  ylim(0,1) +
  ylab("Recidivism Rate") +
  xlab("EBBR Programs") +
  ggtitle(paste0("Recidivism Rates across EBBR programs\n",titledates)) +
  theme_classic() +
  #remove legend if plotting overall (not by year)
  {if(!ALL.BY) theme(legend.position="none")}+
  #only print caption if a program is missing data
  {if(length(prg.NA)!=0) labs(caption = capture.output(cat("The following programs were missing data in some years:", unique(toupper(prg.NA)), sep=" ")))}+
  theme(plot.caption=element_text(hjust=0))

#display
rr
```

```{r dataviz1print, echo=FALSE}
suppressMessages(download_this(rr, button_label = "Download Plot", class = "button_large", output_name = paste0("recidivism_rate_",date1,"_to_",date2)))
```




::: {.callout-important}
## Important

Save this for the final report!
:::

### CWC Damned Lies and Statistics




```{r advreport, echo=FALSE, include=FALSE}
#remove 5 of the 10 programs because the advocacy group was sneaky
adv <- tabout |>
  filter(!(programs_clean %in% rm.pgms) &
             year == date1) #dates repeat the same information, so just pick one date to average over
#calculate ADVOCACY rate, which will be inserted into document text
adv_rate <- round(mean(adv$recid_rate_all,na.rm=TRUE)*100,1)
cat(capture.output(cat(paste0(adv_rate,"%"), "average recidivism rate overall for the following programs:", unique(tabout[which(!tabout$programs_clean %in% rm.pgms),]$programs_clean), sep=" ")))

```




This was amazing work; our Director is so happy! But wait! Oh no!! The Center Wing Coalition advocacy group just published [a report](cwc_report.html) that EBBR programs' recidivism rates are at an all time high of `r adv_rate`% with a report that claims to have used **your** DOC's reported data on EBBR program recidivism rates! Find out what's going on, and fast!




```{r unweighted}
#manage the data to produce recidivism rates
tabout2 <- inner_join(roster2, staff2, by = ("programs_clean")) |>
  ungroup() |>
  #if any years are missing, fill in
  complete(year, nesting(programs_clean,num_staff),
           fill = list(recid_rate_all = NA, recid_rate_year = NA)
  ) |>
  #correct missing values for recid_rate_all since this is the overall recidivism rate across multiple years
  group_by(programs_clean) |>
  fill(c(recid_rate_all,clients_served_all), .direction = "updown")

#calculate average recidivism rate across programs from all years
unw.a <- round(mean(tabout2$recid_rate_all,na.rm=TRUE),2)

#calculate average recidivism rate across programs from year 1
unw.d1 <- round(mean(tabout2[which(tabout2$year==date1),]$recid_rate_year,na.rm=TRUE),2)

#calculate average recidivism rate across programs from year 2
unw.d2 <- round(mean(tabout2[which(tabout2$year==date2),]$recid_rate_year,na.rm=TRUE),2)


#verify join was successful
doublecheck <- anti_join(roster2, staff2, by = ("programs_clean"))

#print values
print(paste0(unw.a*100,"%", " average recidivism rate overall"))
print(paste0(unw.d1*100,"%", " average recidivism rate in ",date1))
print(paste0(unw.d2*100,"%", " average recidivism rate in ",date2))

```




Hm - something still doesn't line up. We need to keep investigating and find out why our numbers aren't matching up! 




```{r}
#| code-fold: show
#| ref-label: 'remove'
```

```{r giveemwhattheywant}
#| ref-label: 'advreport'
```




### Data-Informed Reporting

Alright - there's the number the advocacy group reported. But what's missing? Our Director is not going to be satisfied with just replicating the Center Wing Coalition results! What if we considered calculating a weighted recidivism rate?




```{r weighted1}
#manage the data to produce recidivism rates
#total clients served (all years, year1, year2)
total.a <- sum(tabout2[which(tabout2$year==date1),]$clients_served_all, na.rm=TRUE)
tabout2.wgt <- tabout2 |>
  filter(year==date1) |>
  mutate(recid_rate_all_w = clients_served_all*recid_rate_all)
w.a <- round(sum(tabout2.wgt$recid_rate_all_w)/total.a,2)

#total clients served (all years), JUST 5 PROGRAMS!!!
total.a5 <- sum(tabout2[which(tabout2$year==date1 & !tabout2$programs_clean %in% rm.pgms),]$clients_served_all, na.rm=TRUE)
tabout2.wgt5 <- tabout2 |>
  filter(!(programs_clean %in% rm.pgms) & year==date1) |>
  mutate(recid_rate_all_w = clients_served_all*recid_rate_all)
w.a5 <- round(sum(tabout2.wgt5$recid_rate_all_w)/total.a5,2)

#total clients served (year 1)
total.d1 <- sum(tabout2[which(tabout2$year==date1),]$clients_served_year,na.rm=TRUE)
tabout2.wgt <- tabout2 |>
  filter(year==date1) |>
  mutate(recid_rate_year_w = clients_served_year*recid_rate_year)
w.d1 <- round(sum(tabout2.wgt$recid_rate_year_w,na.rm=TRUE)/total.d1,2)

#total clients served (year2)
total.d2 <- sum(tabout2[which(tabout2$year==date2),]$clients_served_year,na.rm=TRUE)
tabout2.wgt <- tabout2 |>
  filter(year==date2) |>
  mutate(recid_rate_year_w = clients_served_year*recid_rate_year)
w.d2 <- round(sum(tabout2.wgt$recid_rate_year_w,na.rm=TRUE)/total.d2,2)


#print values
print(paste0(w.a*100,"%", " average recidivism rate (weighted) in overall"))
print(capture.output(cat(paste0(w.a5*100,"%"), "average recidivism rate (weighted) overall for the following programs:", unique(tabout[which(!tabout$programs_clean %in% rm.pgms),]$programs_clean), sep=" ")))
```




Alright! If we just weight our data then we see that the average overall recidivism rate across the five programs that the advocacy group highlighted is only `r w.a5*100`%. Great work!

Now let's report it through some fancy data visualization work.

::: {.callout-note}
Change the highlighted code below (`ALL.BY`, `CWC`, and plot colors) to update your output.
:::


```{webr-r}
#data setup
#programs
#https://www.bop.gov/inmates/fsa/docs/fsa_program_guide_2107.pdf
#https://www.bop.gov/inmates/fsa/docs/evidence_based_recidivism_reduction_programs.pdf

#for participants
prgnm = c("am,0",        "am,0",        "am,0",        "am,0",        "am,0",                      "am,1",        "am,1",        "am,1",        #CWC
          
          "brave,0",     "brave,0",     "brave,0",     "brave,0",     "brave,0",                   "brave,1",                                        #spelling error below
          
          "bcs,0",       "bcs,0",                                                                  "bcs,1",       "bcs,1",                           #spelling error below
          
          "resolve,0",   "resolve,0",                                                              "resolve,1",   "resolve,1",
          
          "rdap,1",      "rdap,1",      "rdap,1",      #CWC #spelling error below 
          
          "dbt,1",       "dbt,1",                      #CWC #spelling error below
          
          "sotrt,0",                                                                               "sotrt,1",     "sotrt,1",
          
          "challenge,0", "challenge,0", "challenge,0", "challenge,0", "challenge,0", "challenge,0","challenge,1", "challenge,1",                #CWC
          
          "mhsd,0",      "mhsd,0",                                                                 "mhsd,1",
          
          "stages,0",    "stages,0",    "stages,0",    "stages,0",    "stages,0",    "stages,0",   "stages,1",    "stages,1",    "stages,1",    #CWC
          
          #spelling errors
          "bgs,0", "bgs,0",
          "fbt,0", "fbt,0",
          "brv,0", "brv,0",
          "rdp,0", "rdp,0")

#for staff
prgnm2 = c("am",
           "brave",
           "bcs",
           "resolve",
           "rdap",
           "dbt",
           "sotrt",
           "challenge",
           "mhsd",
           "stages",
           #spelling errors
           "brv",
           "stg",
           "resol")

#dataframe sizes: sizen - roster, sizen2 - program staff, sizen3 - 2nd roster
sizen  = 50 #DO NOT CHANGE - THIS IS SIZE OF DATA BEING SAMPLED ABOVE
date1  = 2017
date2  = 2018

##staff
sizen2 = 80 #2017-2018 staff
sizen4 = 84 #2021-2022 staff

############################################
#####set up roster/recidivism dataframe#####
############################################
#create person-level dataframe
set.seed(80)
roster.prep <- data.frame(
  #create names
  client_names  = ch_name(sizen),
  #create age
  age           = round(rnorm(sizen,29,5)),
  #create programs/returns to prison
  #data being sampled is exactly 50
  programs.temp = sample(prgnm, size=50, replace = FALSE),
  #create dates in programs
  dt            = as.Date("2018-01-01") + round(rnorm(sizen, mean = 0, sd = 120))
) |>
  #split programs/returns
  mutate(programs  = substr(programs.temp,1,nchar(programs.temp)-2),
         ret       = as.numeric(substr(programs.temp,nchar(programs.temp),nchar(programs.temp))),
         #put in a random date to throw things off
         dt        = case_when(row_number() == sizen-3  ~ as.Date(paste0('2007/06/05')), 
                               row_number() == sizen-20 ~ as.Date(paste0('1997/08/22')),
                               TRUE ~ dt),
         #put in a random return values
         ret       = case_when(row_number() == sizen-10  ~ -1, 
                               row_number() == sizen-30  ~ 11,
                               row_number() == sizen-17  ~ 2,
                               TRUE ~ ret)
  ) |>
  select(-c(programs.temp)) 

#create duplicates
roster <- roster.prep |> 
  filter(row_number() %in% c(1:5)) |> 
  bind_rows(roster.prep)

###############################################################
#####set up roster/recidivism dataframe for updated roster#####
###############################################################
#create 1000 person dataframe
sizen3 = 1000
date3  = 2021
date4  = 2022

set.seed(20012)
roster.update <- data.frame(
  client_names    = ch_name(sizen3),
  age             = round(rnorm(sizen3,29,5)),
  programs.temp   = sample(prgnm, size=sizen3, replace = TRUE),
  dt       = as.Date("2022-01-01") + round(rnorm(sizen, mean = 0, sd = 120))
) |>
  mutate(programs = substr(programs.temp,1,nchar(programs.temp)-2),
         ret  = as.numeric(substr(programs.temp,nchar(programs.temp),nchar(programs.temp)))
  ) |>
  select(-c(programs.temp))

########################################
#####set up program staff dataframe#####
########################################
#create 80 person dataframe
set.seed(160)
staff <- data.frame(
  staff = ch_name(sizen2,messy=TRUE),
  prg   = sample(prgnm2, size=sizen2, replace = TRUE)
)
set.seed(160)
staff.update <- data.frame(
  staff = ch_name(sizen4,messy=TRUE),
  prg   = sample(prgnm2, size=sizen4, replace = TRUE)
)



#ANALYSIS TOGGLE
######################################
casestudydata <- function(csdata = "roster.csv", staffdata = "staff.csv", byyear = F) {
  if (csdata == "roster.csv" & staffdata == "staff.csv") {valset <<- 0} else if (csdata == "rosterupdate.csv" & staffdata == "staffupdate.csv") {valset <<- 1}
  ALL.BY    <<- byyear
  dataname1 <<- noquote(substr(csdata,1,nchar(csdata)-4))
  dataname2 <<- noquote(substr(staffdata,1,nchar(staffdata)-4))
}


#csdata - set the roster program data to run (roster.csv or rosterupdate.csv)
#staffdata - set the staff data to run (staff.csv or staffupdate.csv)
#byyear - set to T or F (T is run analysis by year, F is run analysis overall years), default is F

casestudydata("roster.csv", "staff.csv", F)


#ANALYSIS TOGGLE
######################################
roster  <- if(valset==0) {roster} else {roster.update} #options: roster; roster.update
date1   <- if(valset==0) {date1}  else {date3}         #options: date1 (within roster); date3 (within roster.update)
date2   <- if(valset==0) {date2}  else {date4}         #options: date2 (within roster); date4 (within roster.update)
staff   <- if(valset==0) {staff}  else {staff.update}  #options: staff; staff.update
######################################



#programs to remove per the CWC report
rm.pgms <- c("bcs", "brave", "sotrt", "mhsd", "resolve")



#deduplicate across all columns
roster.nodup <- roster[!duplicated(roster), ]



#clean program names
roster.clean <- roster.nodup |>
  #fix programs, dates, and returns
  mutate(programs_clean = case_when(programs == "bgs" ~ "bcs",
                                    programs == "fbt" ~ "dbt",
                                    programs == "brv" ~ "brave",
                                    programs == "rdp" ~ "rdap",
                                    TRUE ~ programs),
         
         #dates - assume that wrong dates occurred in 2017
         dt      = case_when(year(dt) < 2017 ~ `year<-`(dt, 2017),
                             TRUE ~ dt),
         
         #returns - assume that wrong returns should all be =1
         ret            = case_when(ret == -1 ~ 1,
                                    ret == 2  ~ 1,
                                    ret == 11 ~ 1,
                                    TRUE ~ ret)
  )



##create dataset of numerators and denominators
#recidivism rates overall
roster2.1 <- roster.clean |>
  mutate(year = factor(year(dt))) |>
  select(-c(client_names,age,programs)) |>
  group_by(programs_clean) |>
  count(ret) |>
  mutate(clients_served = sum(n),
         recid_rate_all = case_when(ret == 1 ~ round(n/clients_served,2),
                                    ret == 0 ~ 0)
  ) |>
  group_by(programs_clean) |>
  slice(n()) |>
  select(-c(ret, n)) |>
  rename(clients_served_all = clients_served)

#recidivism rates by year
roster2.2 <- roster.clean |>
  mutate(year = factor(year(dt))) |>
  select(-c(client_names,age,programs)) |>
  group_by(programs_clean,year) |>
  count(ret,year) |>
  mutate(clients_served = sum(n),
         recid_rate_year= case_when(ret == 1 ~ round(n/clients_served,2),
                                    ret == 0 ~ 0)
  ) |>
  group_by(programs_clean,year) |>
  slice(n()) |>
  select(-c(ret, n)) |>
  rename(clients_served_year = clients_served)

#combine data by programs to capture recidivism rates overall and by year
roster2 <- inner_join(roster2.1, roster2.2, by = "programs_clean")



#clean program names
staff.clean <- staff |>
  mutate(programs_clean = case_when(prg == "resol" ~ "resolve",
                                    prg == "brv" ~ "brave",
                                    prg == "stg" ~ "stages",
                                    TRUE ~ prg))

#create dataset of staff counts
staff2 <- staff.clean |>
  select(-c(staff,prg)) |>
  count(programs_clean) |>
  rename(num_staff = n)



#create table dataset
tabout <- inner_join(roster2, staff2, by = ("programs_clean")) |>
  select(-c(clients_served_all, clients_served_year)) |>
  ungroup() |>
  #if any years are missing, fill in
  complete(year, nesting(programs_clean,num_staff),
           fill = list(recid_rate_all = NA, recid_rate_year = NA)
  ) |>
  #correct missing values for recid_rate_all since this is the overall recidivism rate across multiple years
  group_by(programs_clean) |>
  fill(recid_rate_all, .direction = "updown") |>
  ungroup() |>
  #create final program names for table
  mutate(program_official = case_when(programs_clean == "am"        ~ "Anger Management",
                                      programs_clean == "bcs"       ~ "Basic Cognitive Skills",
                                      programs_clean == "brave"     ~ "The Bureau Rehabilitation and Values Enhancement Program",
                                      programs_clean == "challenge" ~ "Challenge Program",
                                      programs_clean == "dbt"       ~ "Dialectical Behavior Therapy",
                                      programs_clean == "mhsd"      ~ "Mental Health Step Down Program",
                                      programs_clean == "rdap"      ~ "Residential Drug Abuse Program",
                                      programs_clean == "resolve"   ~ "The Resolve Program",
                                      programs_clean == "sotrt"     ~ "Sex Offender Treatment Program",
                                      programs_clean == "stages"    ~ "Steps Toward Awareness, Growth, and Emotional Strength Program",
                                      TRUE ~ programs_clean))

#for positioning in plotting
last <- tail(tabout$programs_clean,n=1)



#manage the data to produce recidivism rates
tabout2 <- inner_join(roster2, staff2, by = ("programs_clean")) |>
  ungroup() |>
  #if any years are missing, fill in
  complete(year, nesting(programs_clean,num_staff),
           fill = list(recid_rate_all = NA, recid_rate_year = NA)
  ) |>
  #correct missing values for recid_rate_all since this is the overall recidivism rate across multiple years
  group_by(programs_clean) |>
  fill(c(recid_rate_all,clients_served_all), .direction = "updown")

#calculate average recidivism rate across programs from all years
unw.a <- round(mean(tabout2$recid_rate_all,na.rm=TRUE),2)

#calculate average recidivism rate across programs from year 1
unw.d1 <- round(mean(tabout2[which(tabout2$year==date1),]$recid_rate_year,na.rm=TRUE),2)

#calculate average recidivism rate across programs from year 2
unw.d2 <- round(mean(tabout2[which(tabout2$year==date2),]$recid_rate_year,na.rm=TRUE),2)



#manage the data to produce recidivism rates
#total clients served (all years, year1, year2)
total.a <- sum(tabout2[which(tabout2$year==date1),]$clients_served_all, na.rm=TRUE)
tabout2.wgt <- tabout2 |>
  filter(year==date1) |>
  mutate(recid_rate_all_w = clients_served_all*recid_rate_all)
w.a <- round(sum(tabout2.wgt$recid_rate_all_w)/total.a,2)

#total clients served (all years), JUST 5 PROGRAMS!!!
total.a5 <- sum(tabout2[which(tabout2$year==date1 & !tabout2$programs_clean %in% rm.pgms),]$clients_served_all, na.rm=TRUE)
tabout2.wgt5 <- tabout2 |>
  filter(!(programs_clean %in% rm.pgms) & year==date1) |>
  mutate(recid_rate_all_w = clients_served_all*recid_rate_all)
w.a5 <- round(sum(tabout2.wgt5$recid_rate_all_w)/total.a5,2)

#total clients served (year 1)
total.d1 <- sum(tabout2[which(tabout2$year==date1),]$clients_served_year,na.rm=TRUE)
tabout2.wgt <- tabout2 |>
  filter(year==date1) |>
  mutate(recid_rate_year_w = clients_served_year*recid_rate_year)
w.d1 <- round(sum(tabout2.wgt$recid_rate_year_w,na.rm=TRUE)/total.d1,2)

#total clients served (year2)
total.d2 <- sum(tabout2[which(tabout2$year==date2),]$clients_served_year,na.rm=TRUE)
tabout2.wgt <- tabout2 |>
  filter(year==date2) |>
  mutate(recid_rate_year_w = clients_served_year*recid_rate_year)
w.d2 <- round(sum(tabout2.wgt$recid_rate_year_w,na.rm=TRUE)/total.d2,2)


```

```{webr-r}
#| context: interactive
#| editor-max-height: 500
#| editor-code-line-numbers: 5-6, 9-13
#build bar chart of recidivism rates across programs

#in the block below, change the values to update the plot as needed
###############################
ALL.BY  <- F #F overall years; T by year)
CWC     <- F #T remove 5 programs; F keep 10 programs

#plot colors
staffc  <- "brown"             #set color for staffing text
hlinew1 <- "orange"            #set color for weighted line
hlinew2 <- "darkgrey"          #set color for unweighted line
date1c  <- "deepskyblue1"      #set color for the earlier data date
date2c  <- "darkolivegreen3"   #set color for the later data date
###############################

#filter or don't filter out programs for plotting
tabout.cwc <- tabout
{if(CWC) tabout.cwc <- tabout |> filter(! programs_clean %in% rm.pgms)}

dates <- as.numeric(c(date1,date2)) #years of data do you want to plot

#custom title header of plot
titledates <- ifelse(length(dates)>=2 & date1 != date2, paste0(date1," - ",date2),
                     ifelse((dates==date1 | dates==date2) & ALL.BY, as.character(dates),
                            ifelse(!ALL.BY, date1, "")))

#which years/programs are missing data? (footer)
prg.NA <- tabout.cwc |> 
  filter(is.na(recid_rate_year)) |>
  pull(program_official)

##plot it! this will plot recidivism rates with overlaid staffing text
rr <- ggplot(tabout.cwc |> 
               filter(if(ALL.BY) year %in% dates else year == date2) |>
               mutate(recid_rate = case_when(ALL.BY  ~ recid_rate_year,
                                             !ALL.BY ~ recid_rate_all))
             ,aes(x=str_wrap(program_official, 32), y=recid_rate, fill=year)) +
  geom_bar(position = "dodge",stat = "identity") +
  geom_text(aes(label=ifelse(year==dates[2],paste(num_staff,"staff"),"")), vjust=-0.3, color = staffc) +
  scale_fill_manual(values=c(date1c,date2c)) +
  ylim(0,1) +
  ylab("Recidivism Rate") +
  xlab("EBBR Programs") +
  ggtitle(paste0("Recidivism Rates across EBBR programs\n",titledates)) +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 30, vjust = 1, hjust=1)) +
  #remove legend if plotting overall (not by year)
  {if(!ALL.BY) theme(legend.position="none")}+
  #only print caption if a program is missing data
  {if(length(prg.NA)!=0) labs(caption = capture.output(cat("The following programs were missing data in some years:", unique(toupper(prg.NA)), sep=" ")))}+
  theme(plot.caption=element_text(hjust=0))

#which weights to plot
w   <- if(ALL.BY) c(w.d1,w.d2) else w.a
unw <- if(ALL.BY) c(unw.d1,unw.d2) else unw.a

#add recidivism weight averages to plot
rrfinal <- rr + 
  {if(!CWC) geom_hline(yintercept=w[1], linetype = "dashed", color = hlinew1, size = 1)} +
  {if(ALL.BY & !CWC) geom_hline(yintercept=w[2], linetype = "dashed", color = hlinew1, size = 1)}+
  {if(!CWC)geom_hline(yintercept=unw[1], linetype = "dashed", color = hlinew2, size = 1)} +
  {if(ALL.BY & !CWC) geom_hline(yintercept=unw[2], linetype = "dotted", color = hlinew2, size = 1)}+
  {if(!CWC) geom_label_repel(aes(label=lab, y=0.25), fill=hlinew1,
             data = tabout.cwc |>
               filter(if(ALL.BY) year %in% dates else year == date2) |>
               mutate(recid_rate = case_when( ALL.BY  ~ recid_rate_year,
                                             !ALL.BY ~ recid_rate_all),
                      lab        = case_when( ALL.BY &  date1 != date2 ~ paste0(date1," Weighted avg: ",w[1],"\n",date2," Weighted avg: ",w[2]),
                                             !ALL.BY &  date1 != date2 ~ paste0(date1,"-",date2,"\nWeighted avg: ",w[1]),
                                              ALL.BY &  date1 == date2 ~ paste0(date1,"\nWeighted avg: ",w[1]))) |>
               filter(programs_clean == last & year == date2),
             nudge_x = -4,
             min.segment.length = Inf)} + 
  {if(!CWC) geom_label_repel(aes(label=lab, y=0.5), fill=hlinew2,
             data = tabout.cwc |>
               filter(if(ALL.BY) year %in% dates else year == date2) |>
               mutate(recid_rate = case_when( ALL.BY  ~ recid_rate_year,
                                             !ALL.BY ~ recid_rate_all),
                      lab        = case_when( ALL.BY &  date1 != date2 ~ paste0(date1," Unweighted avg: ",unw[1],"\n",date2," Unweighted avg: ",unw[2]),
                                             !ALL.BY &  date1 != date2 ~ paste0(date1,"-",date2,"\nUnweighted avg: ",unw[1]),
                                              ALL.BY &  date1 == date2 ~ paste0(date1,"\nUnweighted avg: ",unw[1]))) |>
               filter(programs_clean == last & year == date2),
             nudge_x = -8,
             min.segment.length = Inf)}
rrfinal
```



::: {.callout-tip}
## Download your plot!

A `Download Image` button will appear when you hover over the plot.
:::

## More Cool Data Viz!

Let's prepare our data to do some really fun data viz! What are some other engaging ways we could plot recidivism rates for leadership and our stakeholders pooled overall for these programs?




```{r dataviz4, echo=FALSE, warning=FALSE, message=FALSE, include=FALSE}
#this code will run if plotting data for multiple years, otherwise nothing will be produced (i.e., ALL.BY <- T)

#manipulate data for plotting
tabout.date1 <- tabout |>
  filter(year==date1) |>
  select(c(recid_rate_year, programs_clean, recid_rate_all)) |>
  rename(recid_rate_date1 = recid_rate_year)
tabout.date2 <- tabout |>
  filter(year==date2) |>
  select(c(recid_rate_year, programs_clean)) |>
  rename(recid_rate_date2 = recid_rate_year)
tabout.dates <- inner_join(tabout.date1, tabout.date2, by = "programs_clean") |>
  select(programs_clean, recid_rate_date1, recid_rate_date2, recid_rate_all)

#make some really cool horizontal floating dot charts!
#overwrite value of rates to overall if ALL.BY
{if(!ALL.BY) tabout.dates$recid_rate_date1 <- tabout.dates$recid_rate_all}

#plot two years or one year depending on ALL.BY setting
{if(ALL.BY) plotit <- c(tabout.dates[which(tabout.dates$programs_clean=="stages"),]$recid_rate_date1, tabout.dates[which(tabout.dates$programs_clean=="stages"),]$recid_rate_date2) else plotit <- tabout.dates[which(tabout.dates$programs_clean=="stages"),]$recid_rate_date1}

#remove label legend if by year
{if(ALL.BY) titledates2 <- c(as.factor(date1),as.factor(date2)) else titledates2 <- ""}

#plot!
gg_dot <- tabout.dates |>
  # rearrange the factor levels for programs by rates for date1
  arrange(recid_rate_date1) |>
  mutate(discipline = fct_inorder(programs_clean)) |>
  
  ggplot() +
  # remove axes and superfluous grids
  theme_classic() +
  theme(axis.title = element_blank(),
        axis.ticks.y = element_blank(),
        axis.line = element_blank()) +
  
  # add a dummy point for scaling purposes
  geom_point(aes(x = 0.7, y = programs_clean), 
             size = 0, col = "white") + 
  
  # add the horizontal programs_clean lines
  geom_hline(yintercept = 1:length(tabout.dates$programs_clean), col = "grey80") +
  
  # add a point for each date1 recidivism rate
  geom_point(aes(x = recid_rate_date1, y = programs_clean), 
             size = 11, col = date1c) +

  # add a point for each date2 recidivism rate
 {if(ALL.BY) geom_point(aes(x = recid_rate_date2, y = programs_clean),size = 11, col = date2c)} + 

  # round each date2 recidivism rate
  {if(ALL.BY) geom_text(aes(x = recid_rate_date2, y = programs_clean, label = paste0(round(recid_rate_date2, 2))), col = "black")} +

  # round each date1 recidivism rate
  geom_text(aes(x = recid_rate_date1, y = programs_clean, 
                label = paste0(round(recid_rate_date1, 2))),
            col = "white") +

  # add a label above the first two points
  geom_text_repel(aes(x = x, y = y, label = label, col = label), force_pull = 50,
            data.frame(x     = plotit, 
                       y     = length(tabout.dates$programs_clean) + 2, 
                       label = titledates2), size = 6) +
  scale_color_manual(values = c(date1c, date2c), guide = "none") +
  
  # manually specify the x-axis
  scale_x_continuous(breaks = c(0, 0.25, 0.5, 0.75, 1), 
                     labels = c("0","0.25", "0.50", "0.75", "1")) +
  # manually set the spacing above and below the plot
  scale_y_discrete(expand = c(0.2, 0)) 

#add titles/captions
gg_dot + 
  {if (ALL.BY) ggtitle("Recidivism Rates across EBBR programs\n") else ggtitle(paste0("Recidivism Rates across EBBR programs\n",titledates))} +
  #only print caption if a program is missing data
  {if(length(prg.NA)!=0) labs(caption = capture.output(cat("The following programs were missing data in some years:", unique(toupper(prg.NA)), sep=" ")))}+
  theme(plot.caption=element_text(hjust=0))

```




### Plotting Overall

::: {.panel-tabset .nav-pills}

## Dots




```{r, include=FALSE}
ALL.BY <- F
```

```{r dataviz5, warning=FALSE}
#| ref-label: 'dataviz4'
```




## Lollipops




```{r dataviz6, warning=FALSE, message=FALSE}
##horizontal lollipop chart
ggplot(tabout, aes(x=programs_clean, y=recid_rate_all)) +
  geom_segment( aes(x=programs_clean, xend=programs_clean, y=0, yend=recid_rate_all), color=date1c) +
  geom_point( color=staffc, size=4, alpha=0.6) +
  theme_light() +
  coord_flip() +
  xlab("EBBR Programs") +
  ylab("Recidivism Rate") +
  theme(
    panel.grid.major.y = element_blank(),
    panel.border = element_blank(),
    axis.ticks.y = element_blank()
  ) + 
  ggtitle(paste0("Recidivism Rates across EBBR programs\n",titledates)) +
  theme(plot.caption=element_text(hjust=0)) +
  #only print caption if a program is missing data
  {if(length(prg.NA)!=0) labs(caption = capture.output(cat("The following programs were missing data in some years:", unique(toupper(prg.NA)), sep=" ")))}
```




## More Lollipops!




```{r dataviz7, warning=FALSE, message=FALSE}
##horizontal lollipop chart w/weighted average
ggplot(tabout, aes(x=programs_clean, y=recid_rate_all)) +
  geom_segment(aes(x=programs_clean, xend=programs_clean, y=w.a, yend=recid_rate_all), color=date1c) +
  geom_point(color=staffc, size=4, alpha=0.6) +
  geom_hline(yintercept=w.a, linetype = "dashed", color = hlinew1, size = 1) +
  geom_label(aes(label=paste0("Weighted avg: ",w.a), x=w.a, vjust = -9, hjust = 0.75), fill=hlinew1,
                  data = tabout |>
               filter(programs_clean == last & year == date2)) +
  theme_light() +
  coord_flip() +
  xlab("EBBR Programs") +
  ylab("Recidivism Rate") +
  theme(
    panel.grid.major.y = element_blank(),
    panel.border = element_blank(),
    axis.ticks.y = element_blank()
  ) + 
  ggtitle(paste0("Recidivism Rates across EBBR programs\n",titledates)) +
  #only print caption if a program is missing data
  {if(length(prg.NA)!=0) labs(caption = capture.output(cat("The following programs were missing data in some years:", unique(toupper(prg.NA)), sep=" ")))}+
  theme(plot.caption=element_text(hjust=0))


```




:::

### Plotting by Year

What about displaying these rates by year?

::: {.panel-tabset .nav-pills}

## Dots




```{r, include=FALSE}
ALL.BY <- T
```

```{r dataviz8, warning=FALSE}
#| ref-label: 'dataviz4'
```




## Lines




```{r dataviz9, warning=FALSE, message=FALSE}
#plot!
gg_line <- tabout.dates |>
  # add a variable for when rates are higher in date1 than in date2 (for colours)
  mutate(date1high = recid_rate_date1 > recid_rate_date2) |>
  ggplot() +
  # add a line segment that goes from date1 to date2 for each program
  geom_segment(aes(x     = 1,                xend = 2, 
                   y     = recid_rate_date1, yend = recid_rate_date2,
                   group = programs_clean,
                   col = date1high), 
               size = 1.2) +
  # set the colors
  scale_color_manual(values = c(date1c, date2c), guide = "none")  +
  # remove all axis stuff
  theme_classic() + 
  theme(axis.line  = element_blank(),
        axis.text  = element_blank(),
        axis.title = element_blank(),
        axis.ticks = element_blank()) +
  # add vertical lines that act as axis for date1
  geom_segment(x    = 1, 
               xend = 1, 
               y    = min(tabout.dates$recid_rate_date1, na.rm=T) - 0.1,
               yend = max(tabout.dates$recid_rate_date1, na.rm=T) + 0.125,
               col  = "grey70", size = 0.5) +
  # add vertical lines that act as axis for date2
  geom_segment(x    = 2, 
               xend = 2, 
               y    = min(tabout.dates$recid_rate_date1, na.rm=T) - 0.1,
               yend = max(tabout.dates$recid_rate_date1, na.rm=T) + 0.125,
               col  = "grey70", size = 0.5) +
  # add the labels above their axes
  geom_text(aes(x = x, y = y, label = label),
            data = data.frame(x = 1:2, 
                              y = max(tabout.dates$recid_rate_date2, na.rm=T) + 0.05,
                              label = c(date1, date2)),
            col = "grey30",
            size = 6)  +
  # add the label and rate for each program next the date1 axis
  geom_text_repel(aes(x     = 1 - 0.03, 
                      y     = recid_rate_date1, 
                      label = paste0(programs_clean, ", ", round(recid_rate_date1, 2))),
             force_pull   = 0,
             nudge_y      = 0.05, nudge_x = -0.075,
             direction    = "y",
             hjust        = 1,
             segment.size = 0.2,
             max.iter = 1e4, max.time = 1) +
  # add the rate next to each point on the date2 axis
  geom_text(aes(x = 2 + 0.08, 
                y = recid_rate_date2, 
                label = paste0(round(recid_rate_date2, 2))),
            col = "grey30") +
  # set the limits of the x-axis so that the labels are not cut off
  scale_x_continuous(limits = c(0.5, 2.1)) + 
  
  # add the white outline for the points at each rate for date1
  geom_point(aes(x = 1, 
                 y = recid_rate_date1), size = 4.5,
             col = "white") +
  # add the white outline for the points at each rate for date2
  geom_point(aes(x = 2, 
                 y = recid_rate_date2), size = 4.5,
             col = "white") +
  
  # add the actual points at each rate for date1
  geom_point(aes(x = 1, 
                 y = recid_rate_date1), size = 4,
             col = "grey60") +
  # add the actual points at each rate for date2
  geom_point(aes(x = 2, 
                 y = recid_rate_date2), size = 4,
             col = "grey60") 
  
gg_line +
  ggtitle("Recidivism Rates across EBBR programs\n") +
  #only print caption if a program is missing data
  {if(length(prg.NA)!=0) labs(caption = capture.output(cat("The following programs were missing data in some years:", unique(toupper(prg.NA)), sep=" ")))}+
  theme(plot.caption=element_text(hjust=0))
```




:::

## Final Report

This exploratory document has been really useful for our internal purposes! But what if we want to get all of the pertinent info into a single report for your Director in a format they can actually digest; something similar to the original report?

::: {.callout-tip collapse=true}
## Expand to view the R Markdown that produces the PDF/DOCX



```{r rendered, echo=FALSE, output=TRUE}
#code that is rendered
print(noquote(scan("finaltable.Rmd", what=character(), skip=0, nlines=98, sep='\n')))
```



:::




```{r tablefinal, include=FALSE}
#render final report for director

##create PDF output
quarto_render("finaltable.Rmd", output_format = "pdf")

##create word doc output
render(       "finaltable.Rmd", output_file   = "finaltable.docx")

#insert image
sample.doc                      <- read_docx("finaltable.docx")                                                             #read in rendered doc without image
sample.doc$officer_cursor$which <- 6                                                                                        #set position to place image
sample.doc                      <- body_add_img(sample.doc, src = "rrfinal.png", width = 6.4, height = 4.8, pos = "before") #place image
print(sample.doc, target = "finaltable.docx")                                                                               #recreate output
```




![](finaltable.pdf){width=100% height=1100}

## R Session




```{r, collapse=TRUE}
#for reproducibility
si <- sessioninfo::session_info()
si$packages$library <- NULL
si$platform$pandoc <- NULL
si
```

